package dictgen

import (
	"errors"
	"fmt"
	"io"
	"strings"
	"text/template"
)

var (
	ErrMultiCharsAndMultiCodes = errors.New("multi chars and multi codes at the same time")
	ErrMissCharOrCode          = errors.New("miss char or code")
)

var dictTpl = `// Code generated by go-wubi. DO NOT EDIT.
// This dictionary contains {{ .count }} characters

package {{ .pkgName }}
var {{ .varName }} = map[string]string{ {{ .dict }} }`

// Generator 字典生成器
type Generator interface {
	// ParseSingle 解析单个数据，根据不同情况，单个数据可能为单字多码或多码单字，但不能同时存在多码多字的情况
	ParseSingle(raw []byte) (codes []string, chars []string, err error)
	// ParseAll 解析完成的字典数据
	ParseAll(raw io.Reader) (dict Dict, err error)
}

func NewDict() Dict {
	return Dict{
		describe: "",
		items:    make(map[string][]string),
	}
}

// Dict 字典结构
type Dict struct {
	describe string
	items    map[string][]string // key=汉字 value=五笔编码
}

// GetCodes 查询字符对应的code列表
func (d Dict) GetCodes(char string) []string {
	return d.items[char]
}

// AddCharWithCodes 添加单字多码数据
func (d Dict) AddCharWithCodes(char string, codes []string) {
codes:
	for _, code := range codes {
		for _, existCode := range d.items[code] {
			if code == existCode {
				continue codes
			}
		}

		d.items[char] = append(d.items[char], code)
	}
}

// AddCodeWithChars 添加单码多字数据
func (d Dict) AddCodeWithChars(code string, chars []string) {
chars:
	for _, c := range chars {
		for _, existCode := range d.items[c] {
			if code == existCode {
				continue chars
			}
		}
		d.items[c] = append(d.items[c], code)
	}
}

// Write 把Dict序列化后写入Writer中
func (d Dict) Write(varName, pkgName string, w io.Writer) error {
	dict := ""
	for char, codes := range d.items {
		cs := strings.Join(codes, ",")
		dict += fmt.Sprintf(`"%s":"%s",`, char, cs)
	}

	tpl, err := template.New(varName).Parse(dictTpl)
	if err != nil {
		return err
	}

	err = tpl.Execute(w, map[string]any{
		"varName": varName,
		"pkgName": pkgName,
		"dict":    dict,
		"count":   len(d.items),
	})
	return err
}
